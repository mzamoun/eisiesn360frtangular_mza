import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { environment } from '../../environments/environment';
import { Relation } from '../model/relation';
import { DataSharingService } from './data-sharing.service';
import { UtilsService } from './utils.service';

const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

@Injectable({ providedIn: 'root' })
export class TableService {

  private myUrl: string;
  private myUrlBatch: string;

  constructor(private http: HttpClient, private utils: UtilsService, private dataSharingService: DataSharingService) {
    this.myUrl = environment.apiUrl + '/tables/';
    this.myUrlBatch = environment.apiUrl + '/batch/';
  }

  relationsData: Relation[] = [];  // contenu JSON des relations pour D3

  getTables(fOk: Function, fKo: Function) {
    this.http.get<string[]>(this.myUrl).subscribe(
      tables => {
        tables = tables.map(t => t)
        tables = tables.sort((a, b) => a.localeCompare(b));
        console.log("getTables tables : ", tables)
        if (fOk) fOk(tables)
      },
      error => {
        console.log("getTables error : ", error)
        if (fKo) fKo(error)
      }
    );
  }

  deleteTableData(table: string, fOk: Function, fKo: Function) {
    this.http.delete(this.myUrl + table).subscribe(
      () => {
        if (fOk) fOk();
      },
      error => {
        if (fKo) fKo(error);
      }
    );
  }

  executeSql(sql, fOk: Function, fKo: Function) {
    let infos = ""
    let sqlResult: any[] = []

    this.http.post<any[]>(this.myUrl + 'execute', sql, {
      headers: { 'Content-Type': 'text/plain' }
    }).subscribe(
      result => {
        sqlResult = result
        if (fOk) fOk(sqlResult)
      }, error => {
        infos = JSON.stringify(error)
        if (fKo) fKo(infos)
      }
    );
  }

  getLinesOfTable(table: string, fOk: Function, fKo: Function) {
    let fct = "getLinesOfTable"

    this.http.get<any[]>(this.myUrl + table).subscribe(
      data => {
        console.log(fct + " table, data : ", table, data)
        if (fOk) fOk(data)
      },
      error => {
        console.log(fct + " error : ", error)
        if (fKo) fKo(error)
      }
    );
  }

  getColsOfTable(table: string, fOk: Function, fKo: Function) {
    let fct = "getColsOfTable"
    console.log(fct + " : table : ", table)
    // let columnMetadata: ColumnDetails[] = [];
    let columnMetadata: any[] = [];
    let mapColType = {}
    let mapColTypeInput = {}

    this.http.get<any[]>(this.myUrl + table + '/columns').subscribe(
      data => {
        console.log(fct + " data : ", data)
        columnMetadata = data;

        columnMetadata = columnMetadata.map(col => ({
          ...col,
          columnName: col.columnName,
          dataType: col.dataType
        }));

        console.log(fct + " columnMetadata : ", columnMetadata)

        if (columnMetadata && columnMetadata.length) {
          for (let ct of columnMetadata) {
            let col = ct.columnName
            let typ = ct.dataType
            mapColType[col] = typ
            mapColTypeInput[col] = this.getTypeInput(col, mapColType)
          }

          if (fOk) fOk(columnMetadata, mapColType, mapColTypeInput)

          console.log(fct + " mapColType : ", mapColType)
          console.log(fct + " mapColTypeInput : ", mapColTypeInput)
        }
      },
      error => {
        console.log(fct + " error : ", error)
        if (fKo) fKo(error)
      }
    );
  }

  getTypeInput(col: string, mapColType: {}) {
    col = (col + "").toUpperCase()
    let typ = (mapColType[col] + "").toUpperCase()
    let res = "text"
    if (typ.includes("DATE")) {
      res = "date"
    } else if (typ.includes("TIMESTAMP")) {
      res = "datetime-local"
    } else if (typ.includes("INT") || typ.includes("NUMBER") || typ.includes("DECIMAL")) {
      res = "number"
    } else if (typ.includes("BOOL")) {
      res = "checkbox"
    }
    return res
  }

  openRelations(fOk: Function, fKo: Function) {
    // Charger les relations du backend
    this.http
      .get<any[]>(this.myUrl + "relations")
      .subscribe({
        next: (res) => {
          console.log("openRelations : res : ", res)
          this.relationsData = res;
          // ðŸ”¥ map pour corriger les noms de colonnes
          if (res && res.length) {
            this.relationsData = res.map(r => ({
              table: r.TABLE_NAME,
              column: r.COLUMN_NAME,
              target_table: r.TARGET_TABLE,
              target_pk: r.TARGET_PK
            }));
          }
          console.log("openRelations : relationsData : ", this.relationsData)

          if (fOk) fOk(this.relationsData)
        },
        error: (err) => {
          console.log("openRelations : err : ", err)
          console.error(err);
          if (fKo) fKo(err)
        },
      });
  }

  exportAllTablesToJson(arg0: (res: any) => void, arg1: (err: any) => void) {
    this.http.get<any>(this.myUrl + "exportAllToJson").subscribe(
      res => {
        console.log("exportAllTablesToJson : res : ", res)
        if (arg0) arg0(res)
      },
      err => {
        console.log("exportAllTablesToJson : err : ", err)
        if (arg1) arg1(err)
      }
    );
  }

  importFromJsonToTable(selectedTable: string, jsonData: any[], fctOk: Function, fctKo: Function) {
    this.http.post(this.myUrl + "importFromJson/" + selectedTable, jsonData).subscribe(
      res => {
        console.log("importFromJsonToTable : res : ", res)
        if (fctOk) fctOk(res)
      },
      err => {
        console.log("importFromJsonToTable : err : ", err)
        if (fctKo) fctKo(err)
      }
    );
  }

  /**
   * 
changer cette methode afin d'afficher le fichier pdf du resultat de l'objet retournÃ© : 
         * CraExportResult : proprietes : 
         * - batchStatus : le statut du batch (COMPLETED, FAILED, etc.)
         * - readCount : le nombre d'items lus par le reader
         * - writeCount : le nombre d'items Ã©crits par le writer
         * - filterCount : le nombre d'items filtrÃ©s par le processor
         * - skipCount : le nombre d'items sautÃ©s par le batch
         * - errors : la liste des erreurs rencontrÃ©es pendant l'exÃ©cution du job, avec
         *  - lineNumber : le numÃ©ro de la ligne du CSV qui a causÃ© l'erreur
         * - errorMessage : le message d'erreur associÃ© Ã  cette ligne
         * - pdfContent : le contenu du fichier PDF gÃ©nÃ©rÃ© par le job de gÃ©nÃ©ration des CRA, sous forme de tableau de bytes
         * Le rÃ©sultat de l'exÃ©cution du job de gÃ©nÃ©ration des CRA est retournÃ© dans la rÃ©ponse de cet endpoint,
         * ce qui permet au client de connaÃ®tre le statut du batch, les compteurs de lecture, Ã©criture, filtrage et saut,
         * ainsi que les erreurs rencontrÃ©es, et d'obtenir le fichier PDF gÃ©nÃ©rÃ© par le job de gÃ©nÃ©ration des CRA.
   */
  runBatchCraExportManually(fOk: Function, fKo: Function) {
    console.log("runBatchCraManually : start")
    let url = this.myUrlBatch + "cra/runExportJobPdf"
    this.http.post(url, null, { responseType: 'blob', observe: 'response' }).subscribe(
      (res: any) => {
        console.log("runBatchCraManually : res : ", res)
        if (res && res.body) {
          const blob = new Blob([res.body!], { type: 'application/pdf' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = 'cra.pdf';
          a.click();
          URL.revokeObjectURL(a.href);
        }
        if (fOk) fOk(res)
      },
      err => {
        console.log("runBatchCraManually : err : ", err)
        if (fKo) fKo(err)
      }
    );

    // this.http.post<any>(url, {}).subscribe(
    //   (res: any) => {
    //     console.log("runBatchCraManually : res : ", res)
    //     if (res && res.body && res.body.result && res.body.result.content) {
    //       console.log("runBatchCraManually OK : content : ", res.body.result.content)
    //       const blob = new Blob([new Uint8Array(res.body.result.content)], { type: 'application/pdf' });
    //       const url = window.URL.createObjectURL(blob);
    //       const a = document.createElement('a');
    //       a.href = url;
    //       a.download = 'cra_export.pdf';
    //       a.click();
    //       window.URL.revokeObjectURL(url);
    //     }
    //     if (fOk) fOk(res)
    //   },
    //   err => {
    //     console.log("runBatchCraManually : err : ", err)
    //     if (fKo) fKo(err)
    //   }
    // );
  }

  runBatchConsultantImportManually(fOk: Function, fKo: Function) {
    console.log("runBatchConsultantImportManually : start")
    const formData = new FormData();
    const fileInput = document.createElement('input');
    fileInput.type = 'file';
    fileInput.accept = '.csv'; // Accepter uniquement les fichiers CSV  
    fileInput.onchange = () => {
      const file = fileInput.files[0];
      formData.append('file', file);
      this.http.post(this.myUrlBatch + "consultant/runImportJob", formData).subscribe(
        res => {
          console.log("runBatchConsultantImportManually : res : ", res)
          if (fOk) fOk(res)
        },
        err => {
          console.log("runBatchConsultantImportManually : err : ", err)
          if (fKo) fKo(err)
        }
      );
    };
    fileInput.click();
  }

  //////////////////

}
